---
layout: post
title: Golang 回调函数作用域实验
categories:
- blog
---

> 这一篇是前几天在公司代码里看到了一个回调函数后，由于对回调函数作用域问题疑惑，自己的测试和想法，从 Golang 开始实验，然后到 Python，最后是 Lisp 里关于作用域有一个特殊的设计。因为是按照顺序记录自己的想法，所以有点杂乱的感觉。

## 写在前面

前几天我在上一任留的代码里面看到了两处使用回调函数的地方，一处是用的包必须使用，另一处是用空接口实现一个方法，需要传进去一个函数来实现。

由于我之前并没有很多使用回调函数的经验，所以就查了一下，然后觉得有必要记录下来。

## 问题
看到代码后有两个问题：

1. 作用域
2. 使用情景

第一个问题是因为我看到在回调函数声明的时候，使用了两个局部变量，我在想回调函数使用这两个变量来自哪里，是来自全局？来自被调用的时候语境？还是来自声明时候的语境？

第二个问题是我想为什么上一任在这里使用回调函数？以及用回调函数有什么优点。

## 作用域问题

我主要有两个疑问，一个是回调函数在调用的时候，使用的变量是`使用时的变量`，还是`定义时的变量`。如果是前者的话，函数如果在从外部传入时，函数内部有一个同名的变量，那么结果就变了。而且 debug 起来会特别麻烦。如果是后者的话，就好很多了，最次无非就是需要根据不同的变量值重新定义一个函数出来，不会出现同一个函数，不同时间使用就产生了不同结果。

为了验证猜想，我在 Golang 里面跑了一下：

~~~golang
package main

import (
	. "fmt"
)

func recallfunc(b int, f func()) {
	Printf("inner b: %d\n", b)
	f()
}

func outer() {
	a := 1
	b := 2

	innerfunc := func() {
		Println(a, b)
	}

	recallfunc(3, innerfunc) //inner b: 3 \n 1,2

	b = 4

	recallfunc(3, innerfunc) //inner b: 3 \n 1,4
}

func main() {
	outer()
}
~~~

结果我在注释里标出来了，可以看出第二次调用`innerfunc`的时候，函数打印的值发生了变化，这里和我上面说的`不会出现同一个函数，不同时间使用就产生了不同结果`出现了矛盾。这里要解释一下，我在上文说的不会产生不同结果是指，调用函数本身如果有一个同名的变量，比如`recallfunc`里的 b，函数在被调用时的值会根据离他最近的那个 b 改变。

上面这个例子可以看出：

1. 回调函数被调用的时候，内部变量不会根据调用函数的同名变量改变。
2. 如果在回调函数声明的命名空间内，值发生了改变，那么回调函数被调用时的行为就会发生改变。

下一个问题是，如果我没记错的话，我之前在看 Golang 书的时候，书里说 Golang 为了避免副作用，所有的值传递，如果不是特殊声明的话，传递的都是复制值，而不是引用。然而上面的例子给人的感觉就是传进去了指针，这样才容易解释回调函数才会根据`outer`里的 b 值发生变化。

如果这个成立，那么我猜测，回调函数在被调用的时候，函数会到声明的地方寻找值，函数是一个引用，而找到值后传入函数的值是复制进去的，这样就说得通了。

## 使用情景问题

验证了作用域的猜想后，下一个想法是为什么要使用回调函数，网上了搜了一圈，自己结合这个项目的代码又想了想，先不想回调函数的作用域问题，在这里使用回调函数的好处是：

1. 传递的参数少了。本来应该传进执行函数的`a`和`b`都被回调函数包裹进去了。
2. 执行函数有更加灵活的处理办法，对 Golang 来讲，声明一个空接口类型，里面的函数可以是一个执行函数，然后执行函数所执行的回调函数就根据类型不同来自由发挥，极大的增加了灵活性和可读性。

如果考虑到回调函数内的值是根据声明时的命名空间变化的，我们可以更改回调函数声明的命名空间中的变量，而不用更改回调函数，从而改变回调函数的行为，进而改变执行函数的行为，而只要关心一个作用域内的变量就好了。

## 闭包？

在想完上面三个回调函数的使用情景后，就觉得这三个情景特别眼熟。发现和 python 里面的闭包的使用场景十分相似。

于是我在 Golang 和 Python 里面各自实验了一下：

~~~golang
package main

import (
	. "fmt"
)

func recallfunc(b int, f func()) {
	Printf("inner b: %d\n", b)
	f()
}

func closure() func() {
	a := 1
	b := 2

	innerfunc := func() {
		Println(a, b)
	}

	a = 5
	return innerfunc
}

func main() {
	ff := closure()
	recallfunc(3, ff) //print 3 \n 5 2
}
~~~

~~~python
def recallfunc(f):
    f()


def outer():
    a, b = 1, 2

    def innerfunc():
        print(a, b)
    return innerfunc


def outer2():
    a, b = 1, 2

    def innerfunc():
        print(a, b)

    b = 5
    return innerfunc


def main():
    ff1 = outer()
    recallfunc(ff1) # 1 2

    ff2 = outer2()
    recallfunc(ff2) # 1 5
~~~

这里看出来 Python 和 Golang 对于函数引用变量的逻辑是一样的。都是在声明时命名空间里寻找变量。

## In Lisp

验证完 Python 后，隐约记得 Lisp 里面有一个让函数脱离局部变量的设计，结合这篇记录的内容，就是说回调函数中的变量脱离声明时的命名空间，而在最近的命名空间寻找变量。把这句话翻译到最开始的 Golang 代码，就是说`recallfunc`里面执行`f()`时，`f()`里面的`b`变成执行函数里面的`b`，也就是3。

至于为什么突然想到这个。。。因为闭包对于 Lisp 来说太基础了，所以就反过来想了一下如果要回调函数使用执行函数内的变量应该怎么办。

查了一下文档和书，这个设计的关键字叫`special`，我直接就抄书里的代码了：

~~~lisp
(let ((x 10))
  (defun foo ()
    x))
	
> (let ((x 20)) (foo))
10

(let ((x 10))
  (defun foo ()
    (declare (special x))
    x))

> (let ((x 20))
  (declare (special x))
  (foo))
20
~~~

缺点就是外部和内部同时都要声明`special`，但是这样就让函数内部变量根据环境不同，来表现不同的行为。

## 最后

我以前也写过奖函数传入函数的代码，但是由于对副作用的敏感，没有在声明函数的时候，不通过参数，而直接使用外部的变量，所以看到上一任的代码就多留意了一下。
