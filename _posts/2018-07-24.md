## 写在前面 ##

从年初开始学 Rust，现在已经动手写了tiny projects 和刷了一些题，中间刻意的使用了不同的写法，和尝试了一些特性，这一篇就是把目前遇到的坑写出来，为了方便查找和复习，开头我会补上目录。

### 目录 ###

+ 递归可选类型（`Option<Box<Self>>`）
+ 在表达式中转移内部类型的所有权
+ 花括号释放所有权
+ deref

## 正文 ##

#### 递归可选类型 ####

Rust 和 Haskell 一样都可以在定义一个新类型（此处类型指Haskell 中的data，Rust 中的struct）中，包含自己。举一个例子就是链表，每一个链表都包含一个头部元素，和一个指向后续链表的指针（或者别的什么名词）。在类型上，一个`List{Node,List}`中就包含一个自己的类型。我这里就称它为递归类型了。

直接跳到最后一个`List`，显然，最后一个`List`就包含一个`Node`，但是没有后续的`List`。所以这个最后这个链表的类型应该是一个`Node`加上一个可选类型`List`，就是Haskell 中的`data List = None | Some List`，`Rust`中写做`Option<T>`。

`Rust`自身还有一个限制是递归类型里面，新类型必须被`Box`包裹起来，`Box`的用法就是把这个变量存在堆中，用的时候就按照这个变量用就好了，后面的`deref`会稍微细写。

所以，最后的`List` 是一个这样的：

```rust
struct ListNode {
    val: i32,
    next: Option<Box<ListNode>>,
}

```

这种类型的坑在于，递归类型会有一层一层找下去的应用场景（如果没有这个场景的话，为什么要用递归类型呢？）。要是方法也适用递归写，还好说，写起来简单，但是用起来，因为Rust 目前还不支持递归优化，所以最终会不会暴栈我也说不准。避免暴栈的话，我可以用循环重写逻辑，但是这时候外部和内部的所有权就开始坑了。（下一节）


#### 在表达式中转移内部类型的所有权 ####

接上，要先解释一下这一节的标题，内部类型指的是上面提到的`Option<Box<Self>>`，当我使用循环操作递归类型的时候，循环要更新一个状态，如果这个状态和外部类型的所有权相关，或者同时在循环内部要使用内部类型的所有权，再如果这个内部所有权的取得是依仗外部所有权的，就容易出现多个坑：

+ 所有权的多次借用
+ 无法移出所有权
+ 变量活得时间不够长

**所有权的多次借用**

我直接找[StackOverflow](https://stackoverflow.com/questions/37986640/cannot-obtain-a-mutable-reference-when-iterating-a-recursive-structure-cannot-b)的例子了。

先看错误再看答案，编译器给了三条错误，第一条就是无法对一个变量多次借用，因为变量本身处在`while`的表达式里，这里有点trick的原因是，因为正常的逻辑是`anchor`在循环体内被修改了，不应该出现借用的问题才对，我的解释是（当然不一定对）编译器并不知道author被改了还是没改，假如`while`里面有一个`if-else`分支用来修改`author`的值，那么修改的条件就是一个runtime时确定的条件，而在编译期，编译器是不知道的，所以就不分青红皂白给你拒了。

然后看看答案是怎么做到的，第一个答案的第一段代码看上去也不正常，但是跳过了编译器的检查。下面看这一段代码：

```rust
struct ListNode {
    val: i32,
    next: Option<Box<ListNode>>,
}

fn check_ten(this: &mut Option<Box<ListNode>>, f: &i32) {
    let mut inner_this = this;
    let mut flag = *f;
    while let Some(t) = inner_this {
        t.val += flag;
        if t.val >= 10 {
            t.val = t.val - 10;
            flag = 1;
        } else {
            flag = 0
        }
        let next = &mut t.next;
        inner_this = next;
    }
}

fn main() {}
```

这段代码编译的时候也会有两个错误，第一个和之前一样，多次借用，另一个是在`inner_this = next` 的时候，`inner_this` 赋值的时候已经被借用，无法赋值。这时候就出现了一个坑，当`let Some(t) = inner_this` 的时候，`inner_this` 依旧被借用，并没有自动被释放掉，这时候第一个**多次借用**错误告诉我们这个借用释放出现在`while`的结束。

直觉上我觉得`while` 表达式的的 `inner_this` 应该被释放掉了，然而没有，修复这个问题其实特别简单：

```rust
.....
fn check_ten(this: &mut Option<Box<ListNode>>, f: &i32) {
    let mut inner_this = this;
    let mut flag = *f;
    while let Some(t) = {inner_this} {
.....
```

把`inner_this` 用花括号扩起来，这样在`while` 表达式后这个变量就drop 掉了，就是说这个变量没了，如果`while` 里面没有再次对这个变量赋值的话，while 循环就没有意义了。这时候注释掉`inner_this = next`这一行，那么编译器就会报错，错误就指向`while`表达式。

花括号在下一节还会写。

**无法移出所有权**

这一个问题主要在`&self`被传入了一些`self`
