---
layout: post
title: 关于 Lisp 的废话（二）
modified: 2016-6-4
tags: study
image:
---


> To eval or not to eval, it is a question

## 写在前面
上一篇讲如何开始学Lisp 和学Lisp 过程中的一点小想法。想写这一篇的原因是因为近来写Lisp 的过程中遇到一些坑，和看了一本《On Lisp》的书，把得到的一些心得记录下来。

我会放入一些代码，同时文字表述尽量写的通俗，这样即使看不懂代码，也能大概知道我在讲什么（不过就我这文笔，可能有点难，多担待吧）。

有代码基础的人，可以将自己想象成编译器，这样可能会更有意思一点。

## 求值问题

之前在[Lisp 语法糖](http://ccqpein.me/Common-Lisp-语法糖/)的文章中有写一点关于Lisp 求值，重点在`‘`和`｀`这两个符号的解释。当时举了一个例子：

>这相当于“我”＝ccQ，这时候我已经被赋值了，意味着当我被引用的时候，这个我字作为一个指向，指向ccQ。
>但是如果我想引用“我”这个字本身，就需要一个指令，告知我此时没有指向，这时候就用quote这个函数。(quote (a b c d))表示，后面的(a b c d)不要被求值，则就会返回列表本身。

「指向」在这里我用求值（eval）这个词代替掉。而求值操作贯穿了整个Lisp，其中的坑大部分都出现在宏中，我后面会讲，先从最开始的列表讲起。

如果给Lisp 的编译器看到了`(1 2 3 4)`，它会认为这是一个含有四个数的列表……吗？答案当然是会，这个代码是这样的`(type-of '(1 2 3 4)) => CONS` （其中返回类型CONS 这里理解成列表没有什么问题，下同）。为什么特地要问这个问题，因为编译器看到的，和我们输入的中间隐藏了一个求值。

**编译器**看到的列表和我们在ide中输入的列表长得不一样，在ide中输入代码`'(1 2 3) => (1 2 3)`，`'`不见了，返回的是个真正的列表。上面引用语法糖部分写过`'(1 2 3)` 的意思是`(quote (1 2 3))`，`quote` 表示后面的那玩意不要求值，为什么多此一举？因为Lisp 会默认求值所有传入的、长得像**S表达式**的东西，而(1 2 3) 我们不希望它是一个S表达式。

我在[上一篇关于Lisp 的废话](http://ccqpein.me/关于-Lisp-的废话/)中讲过，我反而觉得Lisp 的语法相当单纯：

>括号的第一个元素永远是函数（操作符），然后后面都是参数。

那么，我们在ide里面输入(1 2 3)，Lisp 会去调用一个叫“1”的操作符（函数、宏），然后把2，3作为参数传进去。而且，因为ide只接受S表达式输入，所以这个求值是必然会进行的。

再回到list，既然Lisp 会对长得像S表达式的list 进行求值，那么要生成一个list 结构怎么办？只能额外告诉Lisp 不要对它进行求值呗。恭喜，我们回到了话题开始的时候，`(quote (1 2 3))` 是一个可被解读的S表达式，它（quote）的目的就是保护`(1 2 3)`不被Lisp 求值。

这时候一个很诡异的事情出现了：**S表达式在Lisp 中既作为数据结构，又作为语法**。那能不能把程序本身作为数据传入另一个程序，答案是能。

在Lisp 擅长领域中，有一条是用作开发AI（虽然我目前没看到什么成果），而S表达式模糊了数据和语言的边界，通过改变求值的时机，语言可以作为数据被处理。Lisp 的宏（macro）就是为了这种情景存在的。

## 宏展开

在《On Lisp》里面，列举了宏使用的多个场景，其中有两条我用到过，一个是「帮你写程序」，一个是「控制求值顺序」。前者用到了宏展开，而宏展开和控制求值顺序无法分开，相信我，我被坑过。

Lisp 在求值S表达式的时候，如果操作符是个函数，那么就会求值后面的参数，如果参数是一个变量符号，就去找这个变量的值，如果是个表达式就先求值这个表达式。对于人来说，这个顺序就是从最里面的括号求值到最外面的括号。

~~~lisp
(defun test1 (a)
    (list 1 a))
(defvar *x* 3)

(test1 2) => (1 2)
(test1 (list 1 2)) => (1 (1 2)) ;先求值(list ...)
(test1 *x*) => (1 3)
~~~

但这个规则对于宏来说它不一定遵守，对于宏来说，**Lisp 的第一操作是宏展开，然后再进行求值，展开阶段，参数保留成你输入它的模样，不会默认进行求值操作，等展开完了，再进行求值。**

~~~lisp
(defmacro test2 (a) ;宏
    (print a))

(defun test2f (a) ;函数
    (print a))

(test2 (list 1 2)) => (list 1 2)
(test2f (list 1 2)) => (1 2)
~~~

上面这个例子就可以看出来，同样都是打印传入的参数，函数对于参数进行了求值操作，而宏没有，对于宏来说，参数就是那个S表达式。我之前在推上说这是个二次求值，我觉得是宏对于参数是展开完才求值，其实并不准确，应该是**宏在展开的时候可以选择求值或者不求值，在返回到外层后再求值一次。**它可以控制求值的顺序。

~~~lisp 
(defmacro test3 (a b)
           (print b)
           `(print ,a))

(test3 (list 1 2) (list 3 4)) => (LIST 3 4) (1 2)
~~~

## 多重展开

如果定义一个宏的时候，用了另一个宏，展开的时候会是什么样子？

~~~lisp 
(defmacro test4 (&body body)
           `(progn (print "lol") ,@body))

(defmacro test5 (a)
           `(test4 ,a))

(test5 (list 1 2)) => "lol" (1 2)

(pprint (macroexpand-1 '(test5 (list 1 2)))) => 
(TEST4
    (LIST 1 2))
    
(pprint (macroexpand '(test5 (list 1 2)))) =>
(PROGN (PRINT "lol") (LIST 1 2))
~~~

简而言之就是如果宏里面引用了宏，在展开的时候会一直展开到底。

