# 关于Lisp 的废话（三）

## 写在前面
这一篇主要用于自己记录和整理，把一些写CL 过程中自己遇到过的坑写出来。主要是用于自己记录，免得忘掉。同时希望尽量能把想法讲清楚，给有同样疑问的人铺路。

## Lambda List
### 背景
前几天想写一个sigma 实现，根据输入的表达式，指明哪一个变量需要累加，提供候补的变量列表，计算sigma。因为有宏的存在，可以写一个非常通用的版本，[上一篇](http://ccqpein.me/关于-Lisp-的废话-二/)讲过：

> S表达式在Lisp 中既作为数据结构，又作为语法。

所以，通过宏，可以把函数表达式作为一个列表传入，然后把函数表达式中的变量替换掉，实现数学上sigma 的目的。

以下是用`do` 宏写的版本：

~~~lisp
(defmacro sigma (funcExp indPara paraList times)
  "Do simga calculation, for example:
(sigma '(+ 1 2) 1 '(2 3 4) 2) => (+ (+ 2 2) (+ 3 2)) "
  (with-gensyms (result paraPool inFuncExp)
    `(let ((,result 0)
           (,paraPool ,paraList)
           (,inFuncExp ,funcExp))
       (do* ((tt 0 (incf tt)))
            ((= tt ,times))
         (setf (elt ,inFuncExp ,indPara) (elt ,paraPool tt))
         (setf ,result (+ ,result (eval ,inFuncExp))))
       ,result
       )))
~~~

能用是能用，但是巨丑陋，因为宏在展开后和函数没有什么区别（大部分函数都能直接转成一个宏版本），所以其实根本没必要使用宏，即使是在`do` 内部使用`,` 求值，在函数中也可以用`eval` 强行求值。所以简而言之，这段代码烂爆了。

可是它确实能用，想了一下，能用且稳定的原因就是，它完全就是函数的翻译版本。

### 问题出现

由于丑的无法直视，就想写一个纯宏的版本，问题是什么标准算“纯宏”？

在上一篇写了宏中有一个大坑：
> （宏）展开阶段，参数保留成你输入它的模样，不会默认进行求值操作，等展开完了，再进行求值。

但这个问题恰恰是宏相比于函数的一个优势。《on lisp》里面举了一个例子，利用宏没有立刻求值这个特性，写了一个**定义宏时，用于保护宏作用域**的宏。（画外音，《on lisp》里面这个宏写错了，《ANSI Common Lisp》里面写对了，这里直接给出正确的版本）

~~~lisp
(defmacro with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym)))
          ,@body))
~~~

这个宏展开是这个样子的：

~~~lisp
(with-gensyms (a b c)
  (body))
  
> (let ((a (gensyms))
        (b (gensyms))
        (c (gensyms)))
    (body))

~~~

这里可以看出来，本来应该直接求值的`(a b c)` 被保护起来，作为一个列表传入了宏。特别之处在于，`with-gensyms` 在定义的时候，后面传入的参数就

## 求值顺序

## 一点小经验


