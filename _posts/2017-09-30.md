# 回调函数小记

## 写在前面

前几天我在上一任留的代码里面看到了两处使用回调函数的地方，一处是用的包必须使用，另一处是用空接口实现一个方法，需要传进去一个函数来实现。

由于我之前并没有很多使用回调函数的经验，所以就查了一下，然后觉得有必要记录下来。

## 问题
看到代码后有两个问题：

1. 作用域
2. 使用情景

第一个问题是因为我看到在回调函数声明的时候，使用了两个局部变量，我在想回调函数使用这两个变量来自哪里，是来自全局？来自被调用的时候语境？还是来自声明时候的语境？

第二个问题是我想为什么上一任在这里使用回调函数？以及用回调函数有什么优点。

## 作用域问题

我主要有两个疑问，一个是回调函数在调用的时候，使用的变量是`使用时的变量`，还是`定义时的变量`。如果是前者的话，函数如果在从外部传入时，函数内部有一个同名的变量，那么结果就变了。而且 debug 起来会特别麻烦。如果是后者的话，就好很多了，最次无非就是需要根据不同的变量值重新定义一个函数出来，不会出现同一个函数，不同时间使用就产生了不同结果。

为了验证猜想，我在 Golang 里面跑了一下：

~~~golang
package main

import (
	. "fmt"
)

func recallfunc(b int, f func()) {
	Printf("inner b: %d\n", b)
	f()
}

func outer() {
	a := 1
	b := 2

	innerfunc := func() {
		Println(a, b)
	}

	recallfunc(3, innerfunc) //inner b: 3 \n 1,2

	b = 4

	recallfunc(3, innerfunc) //inner b: 3 \n 1,4
}

func main() {
	outer()
}
~~~

结果我在注释里标出来了，可以看出第二次调用`innerfunc`的时候，函数打印的值发生了变化，这里和我上面说的`不会出现同一个函数，不同时间使用就产生了不同结果`出现了矛盾。这里要解释一下，我在上文说的不会产生不同结果是指，调用函数本身如果有一个同名的变量，比如`recallfunc`里的 b，函数在被调用时的值会根据离他最近的那个 b 改变。

上面这个例子可以看出：

1. 回调函数被调用的时候，内部变量不会根据调用函数的同名变量改变。
2. 如果在回调函数声明的命名空间内，值发生了改变，那么回调函数被调用时的行为就会发生改变。

下一个问题是，如果我没记错的话，我之前在看 Golang 书的时候，书里说 Golang 为了避免副作用，所有的值传递，如果不是特殊声明的话，传递的都是复制值，而不是指针。然而上面的例子给人的感觉就是传进去了指针，这样才容易解释回调函数才会根据`outer`里的 b 值发生变化。

那么我只能猜测。。。。

## 使用情景问题



## 闭包？

## In Lisp

package main

import (
	. "fmt"
)

func recallfunc(b int, f func()) {
	Printf("inner b: %d\n", b)
	f()
}

func outer() {
	a := 1
	b := 2

	innerfunc := func() {
		Println(a, b)
	}

	recallfunc(3, innerfunc)

	b = 4

	recallfunc(3, innerfunc)
}

func closure() func() {
	a := 1
	b := 2

	innerfunc := func() {
		Println(a, b)
	}

	a = 5
	return innerfunc
}

func main() {
	outer()
	ff := closure()

	recallfunc(3, ff)
}

-----------------------------------
def recallfunc(f):
    f()


def outer():
    a, b = 1, 2

    def innerfunc():
        print(a, b)
    return innerfunc


def outer2():
    a, b = 1, 2

    def innerfunc():
        print(a, b)

    b = 5
    return innerfunc


def main():
    ff1 = outer()
    recallfunc(ff1)

    ff2 = outer2()
    recallfunc(ff2)

