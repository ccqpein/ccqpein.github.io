---
layout: post
title: Make Common Lisp format function into Rust
---

Someday, I want to use the `format` funcion inside my Rust. So I think I can write it by myself. And someone else can use it and feel a bit Lisp (just a tiny bit). 

After read some articles and study a bit, I usually just use it rather than look close enough to try to make a copy, I figured out there are two big parts I need to make separatly. One is control string, one is arguments input. And reveal them after all. 

I have to say, I thought it should be easy. But nothing is easy when put my hands dirty and facing those details. So, let the journey start.

## Control String ##

When I start with control string, there are things in my mind. First, control string should be make once and use several times. So it is the structure instance that including all matters. Second, it should keep all symbols (like `~a`) and their types (I should define them) inside too.

### Define Types ###

Let me define the type first. Thanks to Rust's very generous type system. I define `TildeKind` enum type like:

```rust
pub enum TildeKind {
    /// ~a
    Va,
	/// there are more kinds too
}
```

I do this because it can easily add new enum members inside and I can focues on one special member for developing the MVP of that member.

There are a lot "TildeKind" in common lisp standard, TBH, I even don't there are such many. Until I write this post, I only implenmented the nessary and the ones I use a lot.

### Parser ###

As the part of control string part, there should be one parsing function can make string to the list of `TildeKind`. Then I can let control string struct keep the `TildeKind` inside and reveal with the arguments. 

At first, I make a parse function as the entrance of all parsers detemining. 

```rust
pub fn parse(c: &mut Cursor<&'_ str>) -> Result<Self, TildeError> {
    let parser = Self::scan_for_kind(c)?;
    parser(c)
}
```

It receive the Cursor type which is using in a lot parsing and scanning string operations. Then `scan_for_kind` will return a function that which parser function should do the job. This is the `scan_for_kind`

```rust
fn scan_for_kind(
    c: &mut Cursor<&'_ str>,
) -> Result<
    Box<dyn for<'a, 'b> Fn(&'a mut std::io::Cursor<&'b str>) -> Result<Tilde, TildeError>>,
    TildeError,
> {
	//
	// some check 
	//

    match buf {
        [b'a', ..] | [b'A', ..] => {
            c.seek(SeekFrom::Current(-buf_offset))
                .map_err(|e| TildeError::new(ErrorKind::ParseError, e.to_string()))?; // back to start
            return Ok(
                #[rustc_box]
                Box::new(Self::parse_value),
            );
        },
		...
}
```

It returns the function of parser and box them for outside calling. Yea, I can just call them inside this function, but control string should be generate just once so I don't think optimization is that matter here.

## Wait, let's think a bit ##

After a lot hard code parser function. I start to think how the traits design I want. I would like it use it like in lisp. Flexible enough and switch the behavior in runtime. Because it have to choose the behaviour in runtime, so it has to be some `Box<T>` magic. If it is `~a` in control string, when it used in somewhere functions, the type it reveal is unknown. It can be string, it can be i32, it can be everything. 

And I have to connect them with the `TildeKind` I defined. It is fun to think about this design.

## Traits ##

## Macros ##

## Arguments ##

## Optimization ##

